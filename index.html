<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Isometric Cube Grid â€“ Mobile-Friendly</title>
  <style>
    html,body{margin:0;padding:0;background:#F5E7DE;overflow:hidden;width:100%;height:100%}
    #field-container{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:min(80vw,420px);height:min(80vw,420px)}
    canvas{width:100%!important;height:100%!important;display:block}
  </style>
</head>
<body>
  <div id="field-container"></div>
  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.152.2';

    const container=document.getElementById('field-container');
    const scene=new THREE.Scene();

    // Orthographic, isometric angle
    const d=30;
    const camera=new THREE.OrthographicCamera();
    camera.position.set(d,d,d);
    camera.lookAt(scene.position);

    const renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
    container.appendChild(renderer.domElement);

    // Grid params
    const spacing=12;
    const count=1; // 3x3
    const cubes=[];
    const material=new THREE.LineBasicMaterial({color:0xC46F52});
    const geometry=new THREE.EdgesGeometry(new THREE.BoxGeometry(6,6,6));
    for(let x=-count;x<=count;x++){
      for(let y=-count;y<=count;y++){
        const cube=new THREE.LineSegments(geometry,material.clone());
        cube.position.set(x*spacing,y*spacing,0);
        scene.add(cube);
        cubes.push(cube);
      }
    }

    // Interaction vars
    const mouse=new THREE.Vector2(0,0);
    const target=new THREE.Vector3();
    const raycaster=new THREE.Raycaster();
    let hasPointer=false; // track if user moved

    function updatePointer(clientX,clientY){
      const rect=container.getBoundingClientRect();
      const x=(clientX-rect.left)/rect.width;
      const y=(clientY-rect.top)/rect.height;
      mouse.x=x*2-1;
      mouse.y=-(y*2-1);
      hasPointer=true;
    }

    // Pointer events (covers mouse + touch)
    window.addEventListener('pointermove',e=>updatePointer(e.clientX,e.clientY),{passive:true});

    // Resize handler
    function onResize(){
      const w=container.clientWidth;
      const h=container.clientHeight;
      const aspect=w/h;
      camera.left=-d*aspect;
      camera.right=d*aspect;
      camera.top=d;
      camera.bottom=-d;
      camera.near=1;camera.far=1000;
      camera.updateProjectionMatrix();
      renderer.setSize(w,h);
    }
    window.addEventListener('resize',onResize);
    onResize();

    // Animation loop
    let clock=new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);

      // If no pointer yet, create a gentle orbiting target
      if(!hasPointer){
        const t=clock.getElapsedTime();
        const r=10;
        target.set(Math.cos(t)*r,Math.sin(t)*r,0);
      }else{
        raycaster.setFromCamera(mouse,camera);
        const planeZ=new THREE.Plane(new THREE.Vector3(0,0,1),0);
        raycaster.ray.intersectPlane(planeZ,target);
      }

      cubes.forEach(cube=>{
        const dist=cube.position.distanceTo(target);
        const scale=1+Math.max(0,1-dist/15)*0.5;
        cube.scale.setScalar(scale);
        const m=new THREE.Matrix4().lookAt(cube.position,target,new THREE.Vector3(0,1,0));
        const q=new THREE.Quaternion().setFromRotationMatrix(m);
        cube.quaternion.slerp(q,0.1);
      });

      renderer.render(scene,camera);
    }
    animate();
  </script>
</body>
</html>
